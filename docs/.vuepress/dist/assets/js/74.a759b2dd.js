(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{585:function(t,e,n){"use strict";n.r(e);var p=n(38),v=Object(p.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"js继承总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js继承总结"}},[t._v("#")]),t._v(" js继承总结")]),t._v(" "),n("p",[t._v("1 . 原型链继承")]),t._v(" "),n("p",[t._v("主要步骤 ： B.prototype = new A()")]),t._v(" "),n("p",[t._v("优缺点 ： 继承了A的方法  ， 但属性共用 ， B无法更改")]),t._v(" "),n("p",[t._v("2 . 构造函数继承\n主要步骤  ：\nB funtion (){\nA.call(this,name,age)\n}")]),t._v(" "),n("p",[t._v("优缺点 ： 继承了A的属性 ，但构造方法没有继承到")]),t._v(" "),n("p",[t._v("3 .  组合继承")]),t._v(" "),n("p",[t._v("主要步骤 ：\n就是将原型链继承 构造函数继承（又叫call继承）  结合")]),t._v(" "),n("p",[t._v("优缺点 ：完成了属性和方法的继承      比较消耗性能  ，  进行了两次A实例化    ， A.call   和   new A")]),t._v(" "),n("p",[t._v("4 ， 寄生组合继承")]),t._v(" "),n("p",[t._v("主要步骤  ：\nB funtion (){\nA.call(this,name,age)\n}")]),t._v(" "),n("p",[t._v("B.prototype  =   Object.craete(A.prototype )")]),t._v(" "),n("p",[t._v("优缺点 ： 完成了属性和方法的继承  ，  B.prototype."),n("em",[t._v("proto")]),t._v(" ==  A.prototype   比较推荐此方法")])])}),[],!1,null,null,null);e.default=v.exports}}]);